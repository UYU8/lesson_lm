# 编译发生在代码执行前一刻 v8执行前会先进行预编译

# 声明提升（发生在编译时）
1.变量声明，声明提升
2.函数声明，整体提升

# 函数体中的预编译（在执行代码过程中发现函数调用时才开始）函数执行上下文
1.创建函数的执行上下文对象 AO（函数内执行上下文对象）activation object
2.找形参?和变量声明，将形参?和变量名作为AO的属性,值为undefined
3.将实参和形参统一
4.在函数体内找函数声明，将函数名作为AO的属性名，值为函数体本身（如果属性名已经存在，则覆盖掉其本身的值）

# 栈只能从上往下访问？？？

# 全局的预编译
1.创建一个全局的执行上下文对象 GO 全局执行上下文
2.在全局找变量声明，变量名作为GO的属性名，值为undefined
3.在全局找函数声明，函数名作为GO的属性名，值为函数体本身

# 调用栈
是用来管理函数调用关系的一种数据结构 在v8引擎中 会专门创建一个栈结构来管理函数的调用关系
v8引擎专门用来追踪函数执行的一个机制
# v8引擎拿到代码后会首先创建一个调用栈，然后才开始预编译全局的代码

先找词法环境，再找变量环境
函数执行完函数执行上下文将会销毁出栈
全局的执行上下文也会销毁出栈